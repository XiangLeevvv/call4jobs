# 设计模式

#### 1. 设计模式分类

- **创建型模式**：

  对类的实例化过程进行抽象，将对象的创建和对象的使用分离。

  工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式

- **结构型模式**：

  关注对象的组成以及对象之间的依赖关系（搭积木）

  适配器模式、装饰器模式、代理模式、（外观模式、桥接模式、组合模式、享元模式）

- **行为型模式**：

  重点关注对象之间的相互作用

  策略模式、观察者模式、模板方法模式、（迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式）

#### 2. 工厂模式 vs 抽象工厂模式 vs 建造者模式

工厂模式（Factory Pattern）和建造者模式（Builder Pattern）是两种常见的创建型设计模式，它们解决了不同类型的问题，具有不同的应用场景和特点。

##### 工厂模式（Factory Pattern）：

1. **目的：** 工厂模式旨在通过工厂方法或抽象工厂来创建对象，而不需要直接使用构造函数。**它将对象的创建和使用进行解耦**，使得代码更易于扩展和维护。
2. **种类：** 工厂模式包括简单工厂模式、工厂方法模式和抽象工厂模式，它们的主要区别在于对象的创建方式和抽象级别。
3. **应用场景：** 当客户端不需要知道具体对象的创建过程，只需通过工厂获取相应的实例时，适合使用工厂模式。特别是当需要根据不同的条件来创建不同类型的对象时，可以使用工厂模式来根据条件动态选择合适的工厂来创建对象。

##### 抽象工厂模式（Abstract Factory Pattern）：

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

- **工厂模式关注单个产品等级结构的对象创建，而抽象工厂模式关注多个产品族的对象创建。**
- **工厂模式只需定义一个工厂类，而抽象工厂模式需要定义多个具体工厂类，每个具体工厂类负责创建一个产品族的对象。**

##### 建造者模式（Builder Pattern）：

1. **目的：** 建造者模式用于**创建复杂对象**，通过将对象的构建过程拆分为多个步骤，使得客户端可以按照自己的需求一步步构建对象，从而灵活地组合和配置对象的属性。
2. **步骤：** 建造者模式包括一个指挥者（Director）和多个具体建造者（Builder），指挥者负责控制建造过程的顺序和逻辑，而具体建造者负责实际构建对象的各个部分。
3. **应用场景：** 当需要创建具有复杂结构的对象，且对象的构建过程比较复杂或者对象的属性需要根据不同的需求来动态配置时，适合使用建造者模式。特别是当对象具有多个属性，且这些属性之间有一定的依赖关系时，可以使用建造者模式来解决对象构建的问题。

##### 区别总结：

- **工厂模式用于创建单个对象或一组相关对象，通过工厂来将对象的创建和使用解耦。**
- **建造者模式用于创建复杂对象，通过将对象的构建过程拆分为多个步骤，使得客户端可以按需构建对象，并且灵活地配置对象的属性。**

在实际应用中，根据具体的场景和需求来选择合适的设计模式，有时甚至可以将工厂模式和建造者模式结合起来使用，以达到更好的设计效果。

#### 3. 原型模式

它通过复制现有对象的原型来创建新的对象实例，而无需知道具体创建过程的细节。