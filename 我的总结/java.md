# java

#### 1. java反射机制（`java.lang.reflect`）

​	Java的反射机制是指**在运行时动态地获取类的信息以及操作类的属性、方法和构造函数的能力**。通过反射，可以在运行时检查类、实例化对象、调用方法、获取和设置字段的值，而无需在编译时知道这些类的具体信息。以下是使用反射的一些常见用途：

1. **获取类的信息：** 可以通过反射获取类的名称、父类、接口、构造函数、方法和字段等信息。
2. **实例化对象：** 可以使用反射来实例化对象，即使在编译时无法确定类的具体类型。
3. **调用方法：** 可以动态地调用类的方法，包括公共方法、私有方法以及静态方法。
4. **操作字段：** 可以获取和设置对象的字段的值，包括公共字段、私有字段以及静态字段。
5. **动态代理：** 可以使用反射来创建动态代理对象，以实现在运行时生成代理类。

#### 2. java的依赖注入（DI——Dependency Injection）

- 依赖注入是一种**设计模式**，也是Spring框架的核心概念之一。

- 作用是去除Java类之间的依赖关系，实现松耦合，减少依赖性，增强可重用性，增加可读性、可扩展性。

  ```java
  // 紧耦合
  class Player{  
      Weapon weapon;  
  
      Player(){  
          // 与 Sword类紧密耦合
          this.weapon = new Sword();  
  
      }  
  
      public void attack() {
          weapon.attack();
      }
  }
  // 松耦合
  class Player{  
      Weapon weapon;  
  
      // weapon 被注入进来
      Player(Weapon weapon){  
          this.weapon = weapon;  
  
      }  
  
      public void attack() {
          weapon.attack();
      }
  
      public void setWeapon(Weapon weapon){  
          this.weapon = weapon;  
      }  
  }
  ```

- 通常有三种依赖注入的方式：

  - 构造器注入（常用）

    ```java
    /**
     * 电脑类
     */
    public class Computer {
    
       /**
        * 电脑的打印机
        */
       private Printer printer;
       
       // 省略getter和setter
    
    }
    public class Computer {
    
       /**
        * 电脑的打印机
        */
       private Printer printer = new Printer();
    
    }
    
    /**
     * 电脑类带参构造器
     * @param printer 传入打印机实例
     */
    public Computer(Printer printer) {
       // 构造器注入
       this.printer = printer;
    }
    
    Printer printer = new Printer();
    // 实例化电脑类，通过构造器注入了打印机实例（依赖）
    Computer computer = new Computer(printer);
    computer.getPrinter().print("构造器注入");
    ```

  - setter注入（常用）

    ```java
    public void setPrinter(Printer printer) {
       this.printer = printer;
    }
    
    Printer printer = new Printer();
    // 实例化电脑类
    Computer computer = new Computer();
    // 通过setter方法注入了打印机实例（依赖）
    computer.setPrinter(printer);
    computer.getPrinter().print("setter注入");
    ```

  - 接口注入

#### 3. 面向对象编程（OOP）

在Java中，你可以**创建类来表示现实世界中的实体或概念**，每个类可以包含数据（成员变量）和方法（成员方法）。然后，你可以使用这些类来创建对象，这些对象可以相互交互并执行特定的任务。例如，你可以创建一个名为`Person`的类，表示人，该类可能包含姓名、年龄等属性，以及吃饭、睡觉等方法。然后，你可以创建多个`Person`对象，每个对象代表一个实际的人，他们可以执行不同的操作。

面向对象编程提供了一种**更加模块化**、**可维护**和**可扩展**的方式来编写代码，**因为它将代码组织成小的、可重用的模块（类和对象），这些模块可以相互协作完成任务。**

#### 4. JDBC

JDBC（Java Database Connectivity）是Java语言中用于与数据库进行交互的一种**标准API**（应用程序编程接口）。**它允许Java应用程序通过SQL语句来执行数据库操作**，如查询、插入、更新和删除数据，以及管理数据库连接等。

除了使用JDBC（Java Database Connectivity），Java还提供了其他访问数据库的方法和框架。以下是一些主要的替代方案：

- #####  Java Persistence API (JPA)

​	JPA是一种用于ORM（对象关系映射）的Java标准，它允许开发人员通过**将Java类映射到关系数据库中的表来管理数据库数据**。最常见的JPA实现是**Hibernate**，它提供了强大的对象关系映射功能，简化了数据库操作。

- ##### Spring Data

​	Spring Data是Spring框架的一部分，它简化了与各种数据存储的交互，包括关系型数据库、NoSQL数据库和其他数据源。Spring Data提供了对JPA、MongoDB、Redis等数据存储的抽象和简化的访问方式。

- ##### MyBatis

​	MyBatis是一个Java持久层框架，它通过XML或注解的方式将SQL语句和Java方法进行映射，提供了灵活而强大的数据库操作功能。MyBatis允许开发人员直接编写原生SQL，同时提供了许多方便的特性，如动态SQL和自动映射。

#### 5. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

- 悲观锁（**每次读取数据或者修改数据时都给数据上锁**）：

  总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以**每次在拿数据的时候都会上锁**，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多 这种锁机制，比如**行锁**，**表锁**等，**读写锁**等，都是在做操作之前先上锁。再比如Java里 面的同步原语**synchronized**关键字的实现也是悲观锁。

- 乐观锁（**读取数据时不会上锁，但更新时需要判断数据是否发生变化**）：

  顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用**版本号**等机制。乐观锁适 用于多读的应用类型，这样可以**提高吞吐量**，像数据库提供的类似于write_condition机制， 其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。

#### 6. 一个对象的两个方法加 synchronized，一个线程进去 sleep，另一个线程可以进入到另一个方法吗？

如果一个对象的两个方法都被 `synchronized` 关键字修饰，那么在同一时间只有一个线程可以访问这个对象的任何一个被 `synchronized` 修饰的方法。这是**因为 `synchronized` 锁住的是对象，而不是方法**。

#### 7. 线程池拒绝策略有哪些？

1. **Abort Policy（默认）：** 当线程池无法处理新提交的任务时，将抛出 `RejectedExecutionException` 异常。这是线程池的默认拒绝策略。
2. **Discard Policy：** 当线程池无法处理新提交的任务时，**将丢弃新任务而不发出任何警告或异常**。这可能会导致任务丢失，不推荐在需要保证任务不丢失的情况下使用。
3. **Discard Oldest Policy：** 当线程池无法处理新提交的任务时，将**丢弃队列中等待时间最长的任务**（即最早提交的任务），然后尝试重新提交新任务。这个策略可以避免 `Discard Policy` 中的任务丢失，但仍然可能导致旧任务被丢弃。
4. **Caller Runs Policy：** 当线程池无法处理新提交的任务时，将使用提交任务的线程（即**调用线程**）来执行该任务。这种策略可以保证任务不会被丢弃，但可能会降低系统的性能。

#### 8. java是值传递

Java 中的参数传递是**按值传递**。这意味着当你调用一个方法时，方法得到的是实际参数值的一个拷贝，而不是参数本身。因此，如果在方法中修改了参数的值，这种改变不会影响原始参数的值。

**然而需要注意的是，对于引用类型的参数，传递的是引用的拷贝，而不是引用本身。这意味着如果你在方法中修改了引用指向的对象的属性，这种改变会影响原始对象的状态。**但是，如果你在方法中修改了引用指向一个新的对象，原始引用不会受到影响。

这种行为可能会导致一些误解，因为在使用引用类型时，通常我们看到的是引用指向的对象，而不是引用本身。但是，实际上，**在传递参数时，传递的是引用的拷贝，因此 Java 中的参数传递被认为是按值传递的。**

#### 9. java不可变类

> 不可变类是指**一旦创建后其状态（即对象的属性）就不能被修改的类**。这种类的实例是不可变的，即它们的状态在创建后不能被更改。在Java中，String类是一个典型的不可变类的例子。

不可变类具有以下特征：

1. **状态不可变性（State Immutability）**：一旦对象被创建，其状态就不能被更改。
2. **线程安全性（Thread Safety）**：由于对象的状态不可更改，因此它们在多线程环境中是安全的，不需要额外的同步。
3. **安全性和保护性（Security and Integrity）**：由于对象的状态不可更改，因此不可变类可以确保对象的完整性和安全性，避免了对象状态被意外或恶意修改的可能性。
4. **缓存友好性（Cacheability）**：不可变对象可以被安全地用作缓存键，因为它们的哈希码和相等性在对象的生命周期内是不变的。

要创建不可变类，通常需要采取以下措施：

- 声明类为`final`，以防止其被子类继承。
- 将类的所有属性声明为`private`，以防止直接访问。
- 不提供修改状态的方法（即不提供修改属性值的setter方法）。
- 如果类包含可变对象引用，应该确保不可变类不会泄漏对这些对象的引用，并且在构造函数中进行适当的防御性拷贝。

#### 10. synchronized

`synchronized` 关键字在多线程访问共享数据时同一时刻只能由单个线程抢到资源去执行。且在线程切换时，涉及到操作系统内核态与用户态的切换，这些操作会消耗额外的资源，因此效率较低。

`Synchronized` 的主要特点包括：

- `synchronized`实现的是**隐式锁**。
- **原子性（Atomicity）：** 由于 `synchronized` 关键字确保了同一时刻只有一个线程可以执行同步代码块或方法，因此它可以保证相关操作的原子性，即这些操作不会被其他线程中断。
- **可见性（Visibility）：** 当一个线程获得了锁并进入了同步代码块或方法时，它会将修改的变量的值刷新到主内存中，其他线程会看到这些变化。这就确保了变量的可见性。
- **互斥性（Mutual Exclusion）：** 当一个线程获得了对象的锁并进入了同步代码块或方法时，其他线程必须等待该线程释放锁才能继续执行同步代码块或方法。这就确保了对共享资源的互斥访问。

Java 中的每⼀个对象都可以作为锁，有三种加锁的⽅式：

- 对于**普通同步⽅法**，锁是**当前实例对象**。
- 对于**静态同步⽅法**，锁是当前类的 **Class 对象**
- 对于**同步⽅法块**，锁是 **Synchonized 括号⾥配置的对象**。

#### 11. 显示锁和隐式锁

1. **显示锁（Explicit Lock）**：
   - 显示锁是通过 `java.util.concurrent.locks` 包中的 Lock 接口及其实现类来实现的，比如 ReentrantLock。
   - 使用显示锁时，需要**手动地获取锁和释放锁，**即通过调用 `lock()` 方法获取锁，通过调用 `unlock()` 方法释放锁。
   - 显示锁提供了**更多的灵活性**，如可以实现公平锁、可中断锁、尝试获取锁等特性。
   - 显示锁适用于需要更细粒度的锁控制、更复杂的同步需求的情况。
2. **隐式锁（Implicit Lock）**：
   - 隐式锁通常是通过 `synchronized` 关键字实现的。
   - 在使用 synchronized 块时，**锁的获取和释放是隐式进行的**，即**进入 synchronized 块时自动获取锁，退出 synchronized 块时自动释放锁**。
   - synchronized 关键字的**锁是与对象关联**的，即每个对象都有一个**内置锁**（也称为**监视器锁**或**互斥锁**），线程需要获取对象的锁才能进入 synchronized 块。
   - 隐式锁相对于显示锁来说，语法更简单，使用更方便，但提供的功能和灵活性相对较少。

#### 12. 自旋锁

在Java中，自旋锁是一种**非阻塞的锁**，**它通过反复检查锁状态来避免线程阻塞**。当一个线程尝试获取锁时，如果锁已经被其他线程持有，那么这个线程不会立即阻塞，而是会在一个循环中反复尝试获取锁，直到获取到为止，或者达到一定的尝试次数。

```java
import java.util.concurrent.atomic.AtomicReference;

// 在这个示例中，AtomicReference被用来存储当前持有锁的线程。lock() 方法中，通过循环不断尝试将当前线程设置为持有者，直到成功设置为止。unlock() 方法则是将当前线程持有的锁释放。
public class SpinLock {
    private AtomicReference<Thread> owner = new AtomicReference<>();

    public void lock() {
        Thread currentThread = Thread.currentThread();
        while (!owner.compareAndSet(null, currentThread)) {
            // 如果锁已经被其他线程持有，则一直尝试获取锁
        }
    }

    public void unlock() {
        Thread currentThread = Thread.currentThread();
        owner.compareAndSet(currentThread, null);
    }
}
```

需要注意的是，**自旋锁适用于锁被持有的时间非常短暂的情况**。如果持有锁的时间较长，那么自旋的线程会一直占用CPU资源，导致性能下降。因此，自旋锁一般在锁的**持有时间很短**，**且竞争不激烈**的情况下才适用。

`java.util.concurrent.atomic.AtomicInteger` 的 `compareAndSet` 方法可以用来实现简单的自旋锁。

#### 13. Java中的锁

根据分类标准我们把锁分为以下 7 大类别，分别是：

1) **悲观锁/乐观锁（并发同步）；**

   Java中`Synchronized`和`ReentrantLock`等独占锁就是悲观锁思想实现的。

   `Lock`是乐观锁的典型实现案例。

2) **公平锁/非公平锁（线程获取锁的抢占机制）**；

   **公平锁：**是指多个线程**按照申请锁的顺序**来获取锁。

   **非公平锁：**是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁(**允许“插队”**的情况存在)。

3) **共享锁/独占锁（锁能否被多个线程持有）**；

   **独占锁：**是指任何时候都只能有一个线程能执行资源操作(**只能被单线程持有的锁**)。比如 `synchronized` 就是独占锁。

   **共享锁：**是指可以同时被多个线程读取，但只能被一个线程修改。（**多线程共享读取，单线程修改**）

   读写锁中的读锁，是共享锁，而写锁是独占锁。

4) **可重入锁/非可重入锁**；

   可重入锁也叫递归锁，指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁(**同一个线程，如果外面的函数拥有此锁之后，内层的函数也可以继续获取该锁**)。

   > 可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为0，当被线程占用和重入时分别加1，当锁被释放时计数器减1，直到减到 0 时表示此锁为空闲状态。

   ```java
   public class LockExample {
       public static void main(String[] args) {
           //可重入锁A
           reentrantA();
       }
   
       /**
        * 可重入锁A方法
        */
       private synchronized static void  reentrantA(){
           System.out.println(Thread.currentThread().getName() + ":执行 reentrantA");
           reentrantB();
       }
   
       /**
        * 可重入锁B方法
        */
       private synchronized static void reentrantB(){
           System.out.println(Thread.currentThread().getName() + ":执行 reentrantB");
       }
   }
   
   // 执行结果
   // main:执行 reentrantA
   // main:执行 reentrantB
   ```

   不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。

   `ReentrantLock` 和` synchronized` 都是可重入锁。

5) 自旋锁/非自旋锁；

   自旋锁的好处是减少了上下文切换的消耗，缺点是CPU空耗。自旋锁适合那些占有锁时间很短的场景。

6) 偏向锁/轻量级锁/重量级锁；

   **这三种锁特指` synchronized` 锁的状态**，偏向锁性能最好，可以避免执行 CAS 操作。而轻量级锁利用自旋和 CAS 避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差。

   - 偏向锁，它会**标记第一个获取锁的线程**，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，这样开销很小，性能最好。

   - 轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过**自旋**的形式尝试获取锁，而不会陷入阻塞。

   - 当多个线程**直接有实际竞争**，且**锁竞争时间长**的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入**阻塞状态**。

7) **可中断锁/不可中断锁**

   `synchronized `关键字修饰的锁代表的是不可中断锁，只能等到拿到锁以后才能进行其他的逻辑处理。

    `ReentrantLock` 是一种典型的可中断锁，例如使用 `lockInterruptibly` 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。

#### 14. Java的包装类

包装类其实就是将基本数据类型包装成对象，因为很多地方需要输入的数据类型是一个Object。

装箱——将基本数据类型包装成包装类

拆箱——将包装类转换成基本数据类型

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);
Integer c = 200;
Integer d = 200;
System.out.println(c == d);

// true
// false
```

在Java中，对于装箱（Boxing）和拆箱（Unboxing）的操作，Java虚拟机会维护一个装箱类型的**缓存池**。这个缓存池的范围通常是**-128** 到**127**。**在这个范围内的装箱操作会重用缓存池中的对象，而不是创建新的对象**。因此，当你比较两个在缓存池范围内的装箱类型时，使用`==`比较的是对象的引用地址，因此会返回`true`。

**对于超出缓存池范围的装箱类型，Java会创建新的对象**，因此使用`==`比较的是对象的引用地址，通常会返回`false`。

#### 15. `synchronized`的作用

- 原子性：确保线程互斥访问
- 可见性：保证共享变量的修改能被及时可见
- 有序性：有效地解决重排序的问题

#### 16. `ThreadLocal`

`ThreadLocal`即线程局部变量，使用线程封闭机制，使得每个线程独立维护一个自己的副本。

- 原理：

  每个线程内部都有一个`ThreadLocalMap`，map中的元素key为`ThreadLocal`，value为值。

**在一个 `ThreadLocal` 实例中，每个线程只能存储一个变量。如果你想要在同一个线程中存储多个相同类型的变量，可以使用多个 `ThreadLocal` 实例。**

- 内存泄漏问题：

  每个线程都有⼀个`ThreadLocalMap`的内部属性，map的key是`ThreaLocal`，定义为弱引用，value是强引用类型。

  垃圾回收的时候会⾃动回收key，而value的回收取决于Thread对象的生命周期。

  一般线程对象的周期比较长，这样value便会一直存在在内存中，随着任务数量变多，value也会越来越多。

  解决⽅法：**每次使⽤完`ThreadLocal`就调⽤它的`remove()`⽅法，手动将对应的键值对删除，从⽽避免内存泄漏。**

#### 17. **ReentrantLock** **是如何实现可重入性的**

`ReentrantLock`内部自定义了同步器`sync`，在加锁的时候通过`CAS`算法，检查当前维护的那个线程ID和当前请求的线程ID是否 一致，如果一致，同步状态加1，表示锁被当前线程获取了多次。

# 并发编程

#### 1. 用户线程和内核线程

- 用户线程：由用户空间程序管理和调度的线程，运行在**用户空间**（专门给应用程序使用）。
- 内核线程：由操作系统内核管理和调度的线程，运行在**内核空间**（只有内核程序可以访问）。

用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。

#### 2. Java线程

> JDK 1.2 之前，Java 线程是基于**绿色线程**（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。
>
> 在 JDK 1.2 及以后，Java 线程改为基于**原生线程**（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。
>
> 一句话概括 Java 线程和操作系统线程的关系：**现在的 Java 线程的本质其实就是操作系统的线程**。

**线程模型**是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：

1. 一对一（一个用户线程对应一个内核线程）
2. 多对一（多个用户线程映射到一个内核线程）
3. 多对多（多个用户线程映射到多个内核线程）

在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是**一对一**的线程模型，也就是**一个 Java 线程对应一个系统内核线程**。

#### 3. Java线程与进程的关系

<img src="/Users/chocolate/Documents/project/call4jobs/我的总结/java-runtime-data-areas-jdk1.8.png" alt="java-runtime-data-areas-jdk1.8" style="zoom:67%;" />

线程共享堆和方法区，但每个线程都有自己的虚拟机栈、本地方法栈和程序计数器。

##### 为什么**程序计数器**、**虚拟机栈**和**本地方法栈**是线程私有的呢？为什么堆和方法区是线程共享的呢？

###### 程序计数器主要有下面两个作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，**程序计数器用于记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

###### 虚拟机栈和本地方法区栈为什么是私有的？

- **虚拟机栈：** 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

###### 堆和方法区为什么是共享的？

- 堆——最大的一块内存，用于存放新创建的对象（几乎所有）

  > 在 Java 中，**基本数据类型的对象**（如 int、short、byte、long、float、double、char、boolean）以及它们的**封装类对象**（如 Integer、Short、Byte、Long、Float、Double、Character、Boolean）并不存储在堆内存中。这些对象通常被称为“基本类型”或“原始类型”。
  >
  > 这些基本类型的对象通常存储在**栈内存**中，而不是堆内存中。在 Java 中，**栈内存用于存储方法调用时的局部变量、方法参数、方法返回值等数据，以及方法调用的执行环境**。因此，基本类型的对象在方法调用时会被分配到栈内存中，并在方法执行完毕后被销毁。

- 方法区——主要用于存放已被加载的类信息、常量、静态变量等

#### 4. 什么是线程安全

线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其**正确性**和**一致性**的描述。

- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

#### 5. Java如何创建线程

- 继承`Thread`类
- 实现`Runnable`接口
- 实现`Callable`接口
- 使用线程池

不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。

严格来说，Java 就只有一种方式可以创建线程，那就是通过**`new Thread().start()`**创建。不管是哪种方式，最终还是依赖于`new Thread().start()`。

#### 6. 什么是线程上下文切换

线程的上下文——线程运行时所需的条件和状态，包括程序计数器、虚拟机栈、本地方法栈等。

发生上下文切换的情况：

- **主动让出 CPU**，比如调用了 `sleep()`, `wait()` 等。
- **时间片用完**，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- **线程被阻塞时**

#### 7. 死锁产生的四个条件

- 资源的互斥访问
- 资源的不可剥夺性
- 线程请求与保持
- 循环等待资源

#### 8. 避免死锁的方法

针对不可剥夺性，当一个线程申请全部资源失败时，释放它已经持有的资源。

使用算法对资源分配进行评估，使其进入安全状态。

> **安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。

###### 实际开发中可以使用什么方法避免死锁？

- **使用定时锁：** 可以尝试使用带有超时参数的锁，这样如果获取锁的操作超时，可以释放已经持有的锁，避免长时间等待导致的死锁。
- **精简锁的持有时间：** 尽量减少锁的持有时间，避免在锁的范围内进行长时间的计算或者 I/O 操作。
- **使用并发工具：** 可以使用并发工具库中提供的高级并发数据结构和同步机制，例如使用并发集合而不是手动管理锁，可以减少死锁的发生。

#### 9. 为什么wait方法定义在Object类中，而sleep方法定义在Thread类中

因为wait方法是让获取当前对象锁的线程等待，同时释放当前对象锁，因此定义在Object类中。

而sleep方法是让当前线程短暂停止运行，也不会释放任何锁，所以应该定义在Thread类中。

#### *10. 可以直接调用Thread中的`run`方法吗？

不可以，因为直接调用`run`方法并不会启动多线程，而是将`run`方法当作main线程下的一个普通函数进行调用。

真正开启多线程的方法是new 一个 `Thread`，线程进入了新建状态，然后调用Thread类中的`start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 

#### 11. 构造方法可以用`synchronized `修饰吗

不可以，因为构造方法本身就是线程安全的。

#### 12. 读写锁

**在线程持有读锁的情况下，该线程不能取得写锁。**（因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有）

**在线程持有写锁的情况下，该线程可以继续获取读锁。**（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）

#### *13. 线程池

线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

###### 如何创建线程？

- **通过`ThreadPoolExecutor`构造函数来创建（推荐）**。

###### 线程池的参数

**`ThreadPoolExecutor` 3 个最重要的参数：**

- **`corePoolSize` :** 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- **`maximumPoolSize` :** 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

###### 线程池执行过程

<img src="/Users/chocolate/Documents/project/call4jobs/我的总结/线程池执行过程.png" alt="线程池执行过程" style="zoom:80%;" />
