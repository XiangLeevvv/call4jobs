# Mysql

#### 1. 事务的四大特性（ACID）

- ##### 原子性（Atomicity）

  事务的执行要么全部成功，要么全部失败

- ##### 一致性（Consistency）

  一个事务执行之前和执行之后都必须处于一致性状态

- ##### 隔离性（Isolation）

  MySQL数据库提供的四种隔离级别：

  - **Serializable** (串行化)：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
  - **Repeatable read** (可重复读)：MySQL的**默认事务隔离级别**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。
  - **Read committed** (读已提交)：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。
  - **Read uncommitted** (读未提交)：所有事务都可以看到其他未提交事务的执行结果。

- ##### 持久型（Durability）

  事务提交后数据库中的数据变化是永久的

#### 2. 三大范式

- **第一范式1NF**

  所有字段不可拆分，即字段的原子性

- **第二范式2NF**

  在第一范式的基础上，每个表都有一个主键，并且所有非主键都要完全依赖于主键

- **第三范式3NF**

  在第二范式的基础上，去除传递依赖，即所有非主键必须直接依赖于主键

- **巴斯-科德范式BCNF**

  BCNF与3NF的不同之处在于：第三范式中不允许非主属性被另一个非主属性决定，但第三范式允许主属性被非主属性决定；而在BCNF中，任何属性（包括非主属性和主属性）都不能被非主属性所决定。

- ##### 候选键

  通俗地说就是，能够确定全部属性的某个属性或某组属性，称为候选键。若候选键多于一个，则选定其中一个作为主键。

- ##### 主属性

  包含在任何一个候选键中的属性，叫做主属性(Prime attribute),不包含在任何候选键中的属性称为非主属性或非键属性或非关键字段。

#### 3. 字段类型

|   类型   |              描述              |    大小    |
| :------: | :----------------------------: | :--------: |
| Smallint |             小数据             |   2bytes   |
|   Int    |            标准整数            |   4bytes   |
|  Bigint  |             大数据             |   8bytes   |
|  float   |          单精度浮点数          |   4bytes   |
|  Double  |          双精度浮点数          |   8bytes   |
| Decimal  | 字符串类型的浮点数（金融计算） | M*D+2bytes |

```sql
# M表示总共的数字位数（整数部分和小数部分的总长度），而D表示小数部分的位数。
# M 的取值范围是 1 到 65。
# D 的取值范围是 0 到 30。如果省略 D 参数，则默认为 0。
CREATE TABLE example (
    price DECIMAL(7,2)
);
```

#### 4. 字段属性

- Unsigned——无符号整数，该列不能为负数
- zerofill——不足的位数用0填充
- 自增——可自定义起始值和步长
- 非空——not null
- Default——默认值

```sql
create table if not exists `user` (
  `id` int(4) not null auto_increment,
  `name` varchar(255) not null default '匿名' comment '姓名',
  primary key(`id`)
)engine=innodb default charset=utf8
```

#### 5. InnoDB vs MylSAM

- **Mysql默认使用InnoDB**

- InnoDB优缺点：

  - **优点**：支持事务和崩溃修复能力；引入了行级锁和外键约束。
  - **缺点**：占用的数据空间相对较大。
  - **适用场景**：需要事务支持，并且有较高的并发读写频率。

- MyISAM优缺点

  - **优点**：访问速度快。
  - **缺点**：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键
  - **适用场景**：对事务完整性没有要求；表的数据都会只读的。

- InnoDB和MylSAM的区别

  - **事务支持**：
    - **InnoDB 支持事务**（ACID 属性），这意味着它能够实现事务的原子性、一致性、隔离性和持久性，使其适用于要求数据完整性和并发控制的应用。
    - **MyISAM 不支持事务**，因此不具备事务的原子性和隔离性等特性。它更适用于只读或者很少写入的数据，比如日志、归档等应用场景。

  - **并发性**：

    - **InnoDB 支持行级锁定**，这使得在高并发环境下能够更好地处理并发请求，因为不同的事务可以同时修改同一张表中的不同行。

    - **MyISAM 只支持表级锁定**，这意味着在有写入操作的情况下会锁定整个表，可能会导致并发性能下降。

  - **崩溃恢复**：

    - **InnoDB 提供了崩溃恢复机制**，它能够在数据库发生崩溃或非正常关闭时，通过重做日志（Redo Log）来实现数据的一致性恢复。

    - **MyISAM 不支持崩溃恢复**，它更容易在崩溃时发生数据损坏或丢失。

  - **外键约束**：

    - **InnoDB 支持外键约束**，可以通过外键实现关联表之间的完整性约束，确保数据的一致性。

    - **MyISAM 不支持外键约束**，因此需要在应用层面来保证数据的一致性。

  - **全文索引**：
    - MyISAM 支持全文索引（Full-Text Indexing），而 InnoDB 在早期版本中不支持全文索引，但在MySQL 5.6及更高版本中也开始支持全文索引。

#### 6. Delete vs Truncate

在 MySQL 中，DELETE 和 TRUNCATE 是用于删除表中数据的两个不同的操作，它们之间有几个重要的区别：

1. **操作类型**：
   - DELETE 是一种 **DML**（Data Manipulation Language）操作，它是一种逐行删除的操作，可以根据条件删除表中的一部分数据。
   - TRUNCATE 是一种 **DDL**（Data Definition Language）操作，它是一种快速删除整个表中的所有数据的操作，而不考虑条件。
2. **事务处理**：
   - **DELETE 操作可以在事务中使用，并且可以通过回滚来撤销操作**，因为它是 DML 操作。
   - **TRUNCATE 操作不能在事务中使用，因为它是 DDL 操作**，而且它不会记录在事务日志中，因此也无法通过回滚来撤销。
3. **性能**：
   - **TRUNCATE 操作通常比 DELETE 操作更快**，因为它是直接删除整个表的操作，而不需要逐行删除数据，并且不记录在事务日志中，因此可以更快地释放存储空间。
   - DELETE 操作可能会比较慢，特别是当删除大量数据时，因为它需要逐行删除，并且可能会触发触发器、引发级联删除等操作。
4. **自增计数器**：
   - DELETE 操作删除的数据行后，**表中的自增计数器（AUTO_INCREMENT）不会重置**，继续增长。但重启数据库后自增计数器会重置，因为auto_increment是存在内存中的。
   - **TRUNCATE 操作会重置表中的自增计数器，将其重新设置为初始值。**
5. **权限**：
   - DELETE 操作要求用户对表有 DELETE 权限。
   - TRUNCATE 操作要求用户对表有 DROP 权限。

因此，在选择使用 DELETE 还是 TRUNCATE 时，需要根据具体情况来决定。如果需要逐行删除、希望记录在事务日志中、或者需要触发触发器等操作，则应该使用 DELETE。如果需要快速删除整个表的数据、不需要记录在事务日志中、或者需要重置自增计数器，则应该使用 TRUNCATE。

#### 7. 脏读、不可重复读、幻读

- **脏读**是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- **不可重复读**是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，**另一个事务修改了数据并提交了**。
- **幻读**是当某个事务在读取**某个范围内的记录**时，另外一个事务又在该范围内**插入了新的记录**。对幻读的正确理解是一个事务内的读取操作的结论不能支撑之后业务的执行。**假设事务要新增一条记录，主键为id，在新增之前执行了select，没有发现id为xxx的记录，但插入时出现主键冲突，这就属于幻读**，读取不到记录却发现主键冲突是因为记录实际上已经被其他的事务插入了，但当前事务不可见。

**不可重复读和脏读的区别**是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

#### 8. 生产环境的隔离级别

MySql的默认隔离级别是RR（Repeateable Read）

Oracle 数据库的默认隔离级别是RC（Read Committed）

**生产环境大多使用RC**。为什么不是RR呢？

> 可重复读(Repeatable Read)，简称为RR 读已提交(Read Commited)，简称为RC

- **性能和并发性**：可重复读隔离级别会在事务执行期间**锁定满足查询条件的所有数据**，以确保事务内的一致性，从而降低系统的性能。而读已提交隔离级别更灵活，**只在读取数据时锁定行，而不会锁定整个事务范围内的数据**，因此在高并发环境下通常会具有更好的性能。
- **事务持续时间**：在可重复读隔离级别下，由于事务期间读取的数据将保持一致性，因此事务的持续时间可能会更长。而读已提交隔离级别在事务中允许读取到最新提交的数据，因此事务的持续时间可能更短，这对于**减少锁定时间**、**提高并发性能**是有利的。

#### 9. 索引

> MySQL对索引的定义为：索引是帮助MySQL高效获取数据的**数据结构**。
>
> InnoDB 默认采用**B+树**作为其索引结构

##### 分类：

- 主键索引（PRIMARY KEY）
- 唯一索引（UNIQUE KEY）
- 常规索引（KEY/INDEX）默认
- 全文索引（FULLTEXT INDEX）数据定位
- 组合索引（Composite Index），它由多个列组成而不是单个列，它允许在多个列上同时进行查询和排序。

#### 10. 索引原则

- 索引不是越多越好

- 不要对经常变动的数据加索引

- 小数据量的表不用加索引

- 索引一般加在常用来查询的字段上

- 组合索引的列顺序很重要，应该根据最常用的查询条件将列进行排序，以便最大限度地提高索引的效率。

  > 使用组合索引时遵循**最左前缀集合**。也就是说，如果查询涉及组合索引的前几个列，数据库可以有效地利用该索引。但如果查询中使用的列不是组合索引的前缀，那么数据库可能无法使用该索引，而需要进行全表扫描，导致查询效率下降。

#### 11. 索引的原理

- **B+树是数据库系统实现索引的首选数据结构。**

- **索引往往以索引文件的形式存储的磁盘上**：一般来说，索引本身也很大，不可能全部存储在内存中。

- **索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数**：相对于内存存取，I/O存取的消耗要高几个数量级。

- **局部性原理**：当一个数据被使用时，其附近的数据也通常会被马上用到，程序运行期间所需数据通常比较集中。

- **磁盘预读**：磁盘也会从所需位置开始，顺序向后读取一定长度的数据放入内存。由于磁盘顺序读取的效率很高（不需要**寻道时间**，只需很少的**旋转时间**），因此对于具有局部性的程序来说，磁盘预读可以提高I/O效率。

  - **寻道时间**：磁头寻找到指定磁道的时间。
  - **旋转时间**：磁盘旋转到指定扇区的时间。

- 数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。

- B树中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为:
  $$
  O(h)=O(log_dN)
  $$
  一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

- B+树更适合外存索引，原因和**内节点出`d`**有关。从上面分析可以看到，**d越大索引的性能越好**，而出度的上限取决于节点内key和data的大小：
  $$
  d_{max}=floor(pagesize / (keysize + datasize + pointsize)
  $$
  floor表示向下取整。由于**B+树内节点去掉了data域**，因此可以拥有更大的出度，拥有更好的性能。

#### 12. MylSAM的索引 vs InnoDB的索引

- 第一个重大区别是**InnoDB的数据文件本身就是索引文件**，而MyISAM**索引文件和数据文件是分离的**，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的**key**是数据表的**主键**，因此InnoDB表数据文件本身就是主索引。

- 第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。

#### 13. 什么情况下需要索引

- 经常用于查询的字段
- 经常用于连接的字段，建立索引可以加快连接速度
- 经常用于排序的字段，索引可以加快排序搜索的速度

#### 14. 什么情况下不需要索引

- 数据经常增删的字段
- 数据量比较小的情况不需要
- 区分度不高的字段，例如：性别

#### 15. Hash索引 vs B+树索引

- 哈希索引不支持排序，B+树支持
- 哈希索引不支持范围查询，B+树支持
- 哈希索引可能存在哈希冲突，性能不稳定，而B+每个节点的查询都是从根节点查到叶节点，性能稳定

#### 16. 聚集索引

> 聚集索引（Clustered Index）是一种索引结构，其数据行的物理顺序与索引的顺序一致。

**在 MySQL 的 InnoDB 存储引擎中，每张表只能有一个聚集索引，而且这个聚集索引就是该表的主键索引。**

对于`InnoDB`来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的**第一个不允许为`NULL`的唯一索引**。如果没有主键也没有合适的唯一索引，那么`InnoDB`内部会生成一个**隐藏的主键**作为聚集索引，这个隐藏的主键长度为**6个字节**，它的值会随着数据的插入自增。

#### 17. 索引失效

导致索引失效的情况：

- 对于组合索引，不是使用组合索引最左边的字段，则不会使用索引
- 以%开头的like查询如`%abc`，无法使用索引；非%开头的like查询如`abc%`，相当于范围查询，会使用索引
- 查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效
- **判断索引列是否不等于某个值时**
- **对索引列进行运算**
- **查询条件使用`or`连接，也会导致索引失效**

#### 18. 前缀索引

> 前缀索引就是对文本或字符串的前几个字符建立索引，这样索引长度更短，查询速度更快。

```sql
# email列创建前缀索引
ALTER TABLE table_name ADD KEY(column_name(prefix_length));
# 这将在 users 表的 username 列上创建一个前缀长度为 10 的索引，索引名称为 idx_username_prefix。
CREATE INDEX idx_username_prefix ON users (username(10));
```

#### 19. MySQL备份

使用 `mysqldump` 命令来导出数据库的逻辑结构，生成一个 SQL 脚本，包括**表结构**和**数据**。这种备份方式可以**跨平台**使用，并且备份文件可以手动编辑或转移到其他数据库系统中恢复。

```bash
# mysqldump -h ‘主机’ -u ‘用户名’ -p ‘密码’ ‘数据库’ ‘表名1’ ‘表名2’ ... >‘保存位置’
mysqldump -h localhost -u root -p 123456 school student >D:/ 
# 备份整个数据库
mysqldump -u username -p database_name > backup.sql
# 备份所有数据库
mysqldump -u username -p --all-databases > backup.sql
```

#### 20. 分库分表

当单表的数据量达到1000W或100G以后，优化索引、添加从库等可能对数据库性能提升效果不明显，此时就要考虑对其进行切分了。切分的目的就在于减少数据库的负担，缩短查询的时间。数据切分可以分为两种方式：**垂直划分**和**水平划分**。

- 垂直划分数据库是根据业务进行划分。

  - **优点**：行记录变小，数据页可以存放更多记录，在查询时减少I/O次数。
  - **缺点**：
    - 主键出现冗余，需要管理冗余列；
    - 会引起表连接JOIN操作，可以通过在业务服务器上进行join来减少数据库压力；
    - 依然存在单表数据量过大的问题。

  <img src="/Users/chocolate/Documents/project/call4jobs/我的总结/垂直划分.png" style="zoom:80%;" />

- 水平划分是根据一定规则，例如时间或id序列值等进行数据的拆分。

  - **优点**：单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动较少。
  - **缺点**：
    - 分片事务一致性难以解决
    - 跨节点`join`性能差，逻辑复杂
    - 数据分片在扩容时需要迁移

  <img src="/Users/chocolate/Documents/project/call4jobs/我的总结/水平划分.png" style="zoom:80%;" />

- 在MySQL中实现分库分表需要借助中间件，目前比较流行的中间件有`MyCAT`、`Sharding- JDBC`

- 分表策略：

  - 范围划分，按照一定的范围进行划分比如id、date

  - hash取模策略

    > 指定的路由key（一般是`user_id、order_id、customer_no`作为key）对分表总数进行取模，把数据分散到各个表中。一般，我们会取**哈希值，再做取余**
    
    - 优点：hash取模的方式， **不会存在明显的热点问题**。
    
    - 缺点：如果未来某个时候，表数据量又到瓶颈了，需要扩容，就比较麻烦。所以一般建议提前规划好，一次性分够。
    
    - 为了解决这个**扩容迁移**问题，可以使用**一致性hash思想**来解决。
    
      > **一致性哈希**：在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表存在的**动态伸缩**等问题	

#### 21. 跨库Join的几种解决思路

- **字段冗余**：把需要关联的字段放入主表中，避免关联操作；比如订单表保存了卖家ID（ `sellerId`），你把卖家名字 `sellerName`也保存到订单表，这就不用去关联卖家表了。这是一种**空间换时间**的思想。
- **全局表**：比如系统中所有模块都可能会依赖到的一些基础表（即全局表），在每个数据库中均保存一份。
- **数据抽象同步**：比如A库中的a表和B库中的b表有关联，可以定时将指定的表做同步，将数据汇合聚集，生成新的表。一般可以借助 `ETL`工具。
- **应用层代码组装**：**分开多次查询**，调用不同模块服务，获取到数据后，代码层进行字段计算拼装。

#### 22. SQL注入攻击

> SQL注入攻击是一种常见的网络安全攻击，它利用应用程序对用户输入数据的处理不当，向应用程序的后端数据库插入恶意的SQL代码，以执行未经授权的数据库操作。
>
> SQL注入攻击通常发生在基于Web的应用程序中，其中用户可以通过**表单**、**URL参数**或其他方式向应用程序提交数据。**攻击者利用这些输入点，向应用程序提交包含恶意SQL代码的数据**。

1. **登录绕过：** 攻击者可以通过在登录表单中输入恶意的用户名和密码来绕过身份验证，从而成功登录到应用程序。
2. **数据泄露：** 攻击者可以构造恶意的SQL查询，以泄露数据库中的敏感信息，如用户凭据、个人资料等。
3. **数据篡改：** 攻击者可以修改应用程序提交的SQL查询，以修改、删除或插入数据库中的数据，从而对数据进行篡改。
4. **拒绝服务（DoS）：** 攻击者可以构造恶意的SQL查询，导致数据库服务器负载过高，从而使其无法正常工作，造成拒绝服务。

为防止SQL注入攻击，开发人员应采取以下措施：

- **使用参数化查询或预编译语句**：这样可以确保用户输入的数据不会被直接拼接到SQL查询中，从而避免了SQL注入的风险。

  ##### 参数化查询+预编译语句：

  参数化查询是一种执行SQL查询的方法，其中查询字符串中的参数部分使用**占位符**来表示，而不是直接将用户输入的数据插入到SQL查询中。**在执行查询时，参数化查询将占位符替换为真实的参数值，并使用参数化方式将这些值传递给数据库**。

  预编译语句是一种在执行SQL查询之前将查询字符串发送到数据库并进行预编译的方法。在预编译过程中，数据库会对查询字符串进行解析、优化和编译，并生成执行计划，但不会执行实际的查询操作。然后，**应用程序可以多次使用预编译语句来执行不同的查询，只需为每个查询设置参数值即可**。

  例如，在Java中执行参数化查询可以使用**`PreparedStatement`**对象，如下所示：

  ```java
  String sql = "SELECT * FROM users WHERE username = ?";
  // 使用PreparedStatement创建预编译语句
  PreparedStatement pstmt = connection.prepareStatement(sql);
  pstmt.setString(1, userInputtedUsername);
  ResultSet rs = pstmt.executeQuery();
  ```

  在预编译语句中，`?` 是一个占位符，`setString()` 方法用于设置占位符的值为用户输入的用户名。这样，无论用户输入的是什么样的用户名，都不会直接拼接到SQL查询中，从而避免了SQL注入攻击的风险。

- **对用户输入进行严格的验证和过滤**：开发人员应该**对用户输入数据进行验证**，并仅接受符合预期格式和范围的数据。

- 最小化权限：**数据库用户应该被赋予最小必要的权限**，以限制攻击者对数据库的访问权限。
